# Custom Types - Creating custom objects using custom properties
# This demonstrates how to create object-oriented patterns with all types

print("=== Custom Types Examples ===\n")

# ==========================================
# 1. STRING-BASED TYPES
# ==========================================

print("\n--- String-Based Person Type ---")

fn createPerson(name, age) ::
  const person = name

  person.age = age

  person.greet = fn(self) ::
    return "Hello, I'm " + self + " and I'm " + self.age.to_string + " years old"
  end

  person.birthday = fn(self) ::
    self.age = self.age + 1
    return "Happy birthday! Now " + self.age.to_string
  end

  return person
end

const alice = createPerson("Alice", 25)
println(alice.greet)
println(alice.birthday)
println(alice.greet)

# ==========================================
# 2. NUMBER-BASED TYPES
# ==========================================

print("\n--- Number-Based Counter Type ---")

fn createCounter(initial) ::
  const counter = initial

  counter.increment = fn(self) ::
    return self + 1
  end

  counter.decrement = fn(self) ::
    return self - 1
  end

  counter.double = fn(self) ::
    return self * 2
  end

  counter.isPositive = fn(self) ::
    return self > 0
  end

  return counter
end

const count = createCounter(5)
println("Counter: ", count)
println("Increment: ", count.increment)
println("Double: ", count.double)
println("Is positive: ", count.isPositive)

# ==========================================
# 3. ARRAY-BASED TYPES
# ==========================================

print("\n--- Array-Based Stack Type ---")

fn createStack() ::
  const stack = []

  stack.push = fn(self, value) ::
    return self.push(value)
  end

  stack.pop = fn(self) ::
    const value = self.last
    # Note: In a real implementation, we'd remove the last element
    return value
  end

  stack.peek = fn(self) ::
    return self.last
  end

  stack.isEmpty = fn(self) ::
    return self.len == 0
  end

  stack.size = fn(self) ::
    return self.len
  end

  return stack
end

var myStack = createStack()
myStack = myStack.push(10)
myStack = myStack.push(20)
myStack = myStack.push(30)

println("Stack: ", myStack)
println("Peek: ", myStack.peek)
println("Size: ", myStack.size)
println("Is empty: ", myStack.isEmpty)

# ==========================================
# 4. MAP-BASED TYPES (Classic OOP)
# ==========================================

print("\n--- Map-Based Rectangle Type ---")

fn createRectangle(width, height) ::
  const rect = {"width": width, "height": height}

  rect.area = fn(self) ::
    return self["width"] * self["height"]
  end

  rect.perimeter = fn(self) ::
    return 2 * (self["width"] + self["height"])
  end

  rect.isSquare = fn(self) ::
    return self["width"] == self["height"]
  end

  rect.scale = fn(self, factor) ::
    self["width"] = self["width"] * factor
    self["height"] = self["height"] * factor
    return self
  end

  rect.describe = fn(self) ::
    return "Rectangle: " + self["width"].to_string + "x" + self["height"].to_string
  end

  return rect
end

const rect = createRectangle(10, 5)
println(rect.describe)
println("Area: ", rect.area)
println("Perimeter: ", rect.perimeter)
println("Is square: ", rect.isSquare)

# ==========================================
# 5. BOOLEAN-BASED TYPES
# ==========================================

print("\n--- Boolean-Based Flag Type ---")

fn createFlag(initialState) ::
  const flag = initialState

  flag.toggle = fn(self) ::
    if self ::
      return false
    else ::
      return true
    end
  end

  flag.describe = fn(self) ::
    if self ::
      return "Flag is ON"
    else ::
      return "Flag is OFF"
    end
  end

  flag.andWith = fn(self, other) ::
    return self and other
  end

  flag.orWith = fn(self, other) ::
    return self or other
  end

  return flag
end

const myFlag = createFlag(true)
println(myFlag.describe)
const toggled = myFlag.toggle
const toggledFlag = createFlag(toggled)
println("Toggled: ", toggledFlag.describe)

# ==========================================
# 6. COMPLEX EXAMPLE - Vector2D
# ==========================================

print("\n--- Complex Type: Vector2D (using Map) ---")

fn createVector2D(x, y) ::
  const vec = {"x": x, "y": y}

  vec.magnitude = fn(self) ::
    const x2 = self["x"] * self["x"]
    const y2 = self["y"] * self["y"]
    # Simple square root approximation for demo
    return x2 + y2
  end

  vec.add = fn(self, other) ::
    return createVector2D(
      self["x"] + other["x"],
      self["y"] + other["y"]
    )
  end

  vec.scale = fn(self, scalar) ::
    return createVector2D(
      self["x"] * scalar,
      self["y"] * scalar
    )
  end

  vec.dot = fn(self, other) ::
    return self["x"] * other["x"] + self["y"] * other["y"]
  end

  vec.to_string = fn(self) ::
    return "Vec2(" + self["x"].to_string + ", " + self["y"].to_string + ")"
  end

  return vec
end

const v1 = createVector2D(3, 4)
const v2 = createVector2D(1, 2)

println(v1.to_string)
println(v2.to_string)
println("v1 + v2 = ", v1.add(v2).to_string)
println("v1 * 2 = ", v1.scale(2).to_string)
println("v1 · v2 = ", v1.dot(v2))

# ==========================================
# 7. QUEUE (Array-based)
# ==========================================

print("\n--- Array-Based Queue Type ---")

fn createQueue() ::
  const queue = []

  queue.enqueue = fn(self, value) ::
    return self.push(value)
  end

  queue.dequeue = fn(self) ::
    return self.first
    # Note: In a real implementation, we'd remove the first element
  end

  queue.peek = fn(self) ::
    return self.first
  end

  queue.isEmpty = fn(self) ::
    return self.len == 0
  end

  queue.size = fn(self) ::
    return self.len
  end

  queue.to_string = fn(self) ::
    var result = "Queue["
    for i in [0, 1, 2, 3, 4] ::
      if i < self.len ::
        result = result + self[i].to_string
        if i < self.len - 1 ::
          result = result + ", "
        end
      end
    end
    return result + "]"
  end

  return queue
end

var myQueue = createQueue()
myQueue = myQueue.enqueue(10)
myQueue = myQueue.enqueue(20)
myQueue = myQueue.enqueue(30)

println(myQueue.to_string)
println("Peek: ", myQueue.peek)
println("Dequeue: ", myQueue.dequeue)
println("Size: ", myQueue.size)

# ==========================================
# 8. POINT (using multiple base types)
# ==========================================

print("\n--- Point Type with Different Representations ---")

# String-based point
fn createPointString(x, y) ::
  const point = "(" + x.to_string + "," + y.to_string + ")"
  point.x = x
  point.y = y
  return point
end

# Array-based point
fn createPointArray(x, y) ::
  const point = [x, y]
  point.getX = fn(self) :: return self[0] end
  point.getY = fn(self) :: return self[1] end
  point.to_string = fn(self) ::
    return "(" + self[0].to_string + "," + self[1].to_string + ")"
  end
  return point
end

const p1 = createPointString(10, 20)
const p2 = createPointArray(30, 40)

println("String-based point: ", p1, " x=", p1.x, " y=", p1.y)
println("Array-based point: ", p2.to_string, " x=", p2.getX, " y=", p2.getY)

print("\n=== All Custom Types Examples Complete! ===\n")



# Custom Type Patterns - Advanced OOP Patterns
# Demonstrating inheritance-like behavior, composition, and factories

print("=== Advanced Custom Type Patterns ===\n")

# ==========================================
# 1. FACTORY PATTERN - Creating similar objects
# ==========================================

print("\n--- Factory Pattern: Shape Factory ---")

fn ShapeFactory() ::
  const factory = {}

  factory.createCircle = fn(self, radius) ::
    const circle = {"type": "Circle", "radius": radius}

    circle.area = fn(self) ::
      const pi = 3.14159
      return pi * self["radius"] * self["radius"]
    end

    circle.describe = fn(self) ::
      return self["type"] + " with radius " + self["radius"].to_string
    end

    return circle
  end

  factory.createRectangle = fn(self, width, height) ::
    const rect = {"type": "Rectangle", "width": width, "height": height}

    rect.area = fn(self) ::
      return self["width"] * self["height"]
    end

    rect.describe = fn(self) ::
      return self["type"] + " " + self["width"].to_string + "x" + self["height"].to_string
    end

    return rect
  end

  return factory
end

const shapeFactory = ShapeFactory()
const circle = shapeFactory.createCircle(5)
const rect = shapeFactory.createRectangle(10, 20)

println(circle.describe, " - Area: ", circle.area)
println(rect.describe, " - Area: ", rect.area)

# ==========================================
# 2. COMPOSITION PATTERN
# ==========================================

print("\n--- Composition Pattern: Car with Engine ---")

fn createEngine(horsepower) ::
  const engine = {"hp": horsepower, "running": false}

  engine.start = fn(self) ::
    self["running"] = true
    return "Engine started! " + self["hp"].to_string + " HP"
  end

  engine.stop = fn(self) ::
    self["running"] = false
    return "Engine stopped"
  end

  engine.isRunning = fn(self) ::
    return self["running"]
  end

  return engine
end

fn createCar(model, horsepower) ::
  const car = {
    "model": model,
    "engine": createEngine(horsepower),
    "speed": 0
  }

  car.start = fn(self) ::
    return self["engine"].start
  end

  car.accelerate = fn(self, amount) ::
    if self["engine"].isRunning ::
      self["speed"] = self["speed"] + amount
      return "Accelerating... Speed: " + self["speed"].to_string
    else ::
      return "Cannot accelerate. Engine is off."
    end
  end

  car.stop = fn(self) ::
    self["speed"] = 0
    return self["engine"].stop
  end

  car.describe = fn(self) ::
    return self["model"] + " (Engine: " + self["engine"]["hp"].to_string + " HP)"
  end

  return car
end

const myCar = createCar("Tesla Model S", 670)
println(myCar.describe)
println(myCar.start)
println(myCar.accelerate(50))
println(myCar.accelerate(30))
println(myCar.stop)

# ==========================================
# 3. BUILDER PATTERN
# ==========================================

print("\n--- Builder Pattern: PersonBuilder ---")

fn PersonBuilder() ::
  const builder = {
    "name": "",
    "age": 0,
    "city": "",
    "job": ""
  }

  builder.withName = fn(self, name) ::
    self["name"] = name
    return self
  end

  builder.withAge = fn(self, age) ::
    self["age"] = age
    return self
  end

  builder.withCity = fn(self, city) ::
    self["city"] = city
    return self
  end

  builder.withJob = fn(self, job) ::
    self["job"] = job
    return self
  end

  builder.build = fn(self) ::
    const person = {
      "name": self["name"],
      "age": self["age"],
      "city": self["city"],
      "job": self["job"]
    }

    person.describe = fn(self) ::
      return self["name"] + ", " + self["age"].to_string + " years old, " +
             self["job"] + " from " + self["city"]
    end

    return person
  end

  return builder
end

const person = PersonBuilder()
  .withName("John Doe")
  .withAge(30)
  .withCity("New York")
  .withJob("Developer")
  .build

println(person.describe)

# ==========================================
# 4. STATE PATTERN - Array-based state machine
# ==========================================

print("\n--- State Pattern: Traffic Light ---")

fn createTrafficLight() ::
  const light = {
    "currentState": 0,  # 0=red, 1=yellow, 2=green
    "states": ["RED", "YELLOW", "GREEN"]
  }

  light.getCurrentColor = fn(self) ::
    return self["states"][self["currentState"]]
  end

  light.next = fn(self) ::
    self["currentState"] = (self["currentState"] + 1) % 3
    return self
  end

  light.canGo = fn(self) ::
    return self["currentState"] == 2  # green
  end

  light.shouldSlow = fn(self) ::
    return self["currentState"] == 1  # yellow
  end

  light.mustStop = fn(self) ::
    return self["currentState"] == 0  # red
  end

  return light
end

var trafficLight = createTrafficLight()
println("Current: ", trafficLight.getCurrentColor, " - Can go: ", trafficLight.canGo)
trafficLight = trafficLight.next
println("Current: ", trafficLight.getCurrentColor, " - Should slow: ", trafficLight.shouldSlow)
trafficLight = trafficLight.next
println("Current: ", trafficLight.getCurrentColor, " - Can go: ", trafficLight.canGo)

# ==========================================
# 5. INHERITANCE-LIKE PATTERN
# ==========================================

print("\n--- Inheritance Pattern: Animal -> Dog ---")

fn createAnimal(name, species) ::
  const animal = {"name": name, "species": species}

  animal.speak = fn(self) ::
    return self["name"] + " makes a sound"
  end

  animal.describe = fn(self) ::
    return self["name"] + " is a " + self["species"]
  end

  return animal
end

fn createDog(name, breed) ::
  # Create base animal
  const dog = createAnimal(name, "Dog")

  # Add dog-specific properties
  dog["breed"] = breed

  # Override speak method
  dog.speak = fn(self) ::
    return self["name"] + " barks: Woof!"
  end

  # Add new method
  dog.fetch = fn(self) ::
    return self["name"] + " fetches the ball!"
  end

  # Extend describe method
  const originalDescribe = dog.describe
  dog.describe = fn(self) ::
    return originalDescribe + " (Breed: " + self["breed"] + ")"
  end

  return dog
end

const myDog = createDog("Max", "Golden Retriever")
println(myDog.describe)
println(myDog.speak)
println(myDog.fetch)

# ==========================================
# 6. SINGLETON PATTERN (Number-based)
# ==========================================

print("\n--- Singleton Pattern: Configuration ---")

fn getConfig() ::
  const config = 1  # Dummy value, we'll use properties

  config.appName = "MyApp"
  config.version = "1.0.0"
  config.debug = true

  config.get = fn(self, key) ::
    # In a real implementation, we'd have a proper lookup
    if key == "appName" ::
      return self.appName
    else ::
      if key == "version" ::
        return self.version
      else ::
        return self.debug
      end
    end
  end

  config.describe = fn(self) ::
    return self.appName + " v" + self.version + " (Debug: " + self.debug.to_string + ")"
  end

  return config
end

const config = getConfig()
println(config.describe)

# ==========================================
# 7. STRATEGY PATTERN - Different sorting strategies
# ==========================================

print("\n--- Strategy Pattern: Sorter ---")

fn createSorter() ::
  const sorter = {"strategy": "bubble"}

  sorter.setStrategy = fn(self, strategy) ::
    self["strategy"] = strategy
    return self
  end

  sorter.sort = fn(self, data) ::
    if self["strategy"] == "bubble" ::
      return "Bubble sorting array of " + data.len.to_string + " elements"
    else ::
      if self["strategy"] == "quick" ::
        return "Quick sorting array of " + data.len.to_string + " elements"
      else ::
        return "Default sorting array of " + data.len.to_string + " elements"
      end
    end
  end

  return sorter
end

var sorter = createSorter()
const numbers = [3, 1, 4, 1, 5, 9]

println(sorter.sort(numbers))
sorter = sorter.setStrategy("quick")
println(sorter.sort(numbers))

# ==========================================
# 8. OBSERVABLE PATTERN (Array of listeners)
# ==========================================

print("\n--- Observable Pattern: Event Emitter ---")

fn createEventEmitter() ::
  const emitter = {"listeners": []}

  emitter.on = fn(self, listener) ::
    self["listeners"] = self["listeners"].push(listener)
    return self
  end

  emitter.emit = fn(self, event) ::
    var result = "Emitting: " + event
    for listener in self["listeners"] ::
      result = result + " | Listener called"
    end
    return result
  end

  emitter.listenerCount = fn(self) ::
    return self["listeners"].len
  end

  return emitter
end

var emitter = createEventEmitter()
emitter = emitter.on("listener1")
emitter = emitter.on("listener2")

println("Listeners: ", emitter.listenerCount)
println(emitter.emit("data-changed"))

print("\n=== All Advanced Patterns Complete! ===\n")


# Real-World Custom Type Examples
# Practical applications showing custom types in action

print("=== Real-World Custom Type Examples ===\n")

# ==========================================
# 1. TODO LIST APPLICATION
# ==========================================

print("\n--- Todo List Application ---")

fn createTodo(id, title, completed) ::
  const todo = {"id": id, "title": title, "completed": completed}

  todo.toggle = fn(self) ::
    self["completed"] = not self["completed"]
    return self
  end

  todo.to_string = fn(self) ::
    var status = "[ ]"
    if self["completed"] ::
      status = "[✓]"
    end
    return status + " " + self["id"].to_string + ". " + self["title"]
  end

  return todo
end

fn createTodoList() ::
  const list = {"todos": [], "nextId": 1}

  list.add = fn(self, title) ::
    const todo = createTodo(self["nextId"], title, false)
    self["todos"] = self["todos"].push(todo)
    self["nextId"] = self["nextId"] + 1
    return self
  end

  list.complete = fn(self, id) ::
    # In a real app, we'd find and toggle the specific todo
    return "Todo " + id.to_string + " completed"
  end

  list.count = fn(self) ::
    return self["todos"].len
  end

  list.display = fn(self) ::
    var result = "Todo List (" + self["todos"].len.to_string + " items):"
    for todo in self["todos"] ::
      result = result + "\n  " + todo.to_string
    end
    return result
  end

  return list
end

var myTodos = createTodoList()
myTodos = myTodos.add("Learn the language")
myTodos = myTodos.add("Build a project")
myTodos = myTodos.add("Share with friends")

println(myTodos.display)
println("\nTotal todos: ", myTodos.count)

# ==========================================
# 2. SHOPPING CART
# ==========================================

print("\n--- Shopping Cart ---")

fn createProduct(name, price) ::
  const product = {"name": name, "price": price}

  product.to_string = fn(self) ::
    return self["name"] + " ($" + self["price"].to_string + ")"
  end

  return product
end

fn createCart() ::
  const cart = {"items": []}

  cart.add = fn(self, product) ::
    self["items"] = self["items"].push(product)
    return self
  end

  cart.total = fn(self) ::
    var sum = 0
    for item in self["items"] ::
      sum = sum + item["price"]
    end
    return sum
  end

  cart.count = fn(self) ::
    return self["items"].len
  end

  cart.summary = fn(self) ::
    var result = "Shopping Cart (" + self.count.to_string + " items):"
    for item in self["items"] ::
      result = result + "\n  - " + item.to_string
    end
    result = result + "\nTotal: $" + self.total.to_string
    return result
  end

  return cart
end

var cart = createCart()
cart = cart.add(createProduct("Laptop", 999))
cart = cart.add(createProduct("Mouse", 25))
cart = cart.add(createProduct("Keyboard", 75))

println(cart.summary)

# ==========================================
# 3. USER AUTHENTICATION
# ==========================================

print("\n--- User Authentication System ---")

fn createUser(username, password) ::
  const user = {
    "username": username,
    "password": password,
    "loggedIn": false,
    "loginAttempts": 0
  }

  user.login = fn(self, pwd) ::
    if pwd == self["password"] ::
      self["loggedIn"] = true
      self["loginAttempts"] = 0
      return "Welcome, " + self["username"] + "!"
    else ::
      self["loginAttempts"] = self["loginAttempts"] + 1
      return "Invalid password. Attempts: " + self["loginAttempts"].to_string
    end
  end

  user.logout = fn(self) ::
    self["loggedIn"] = false
    return "Goodbye, " + self["username"]
  end

  user.isAuthenticated = fn(self) ::
    return self["loggedIn"]
  end

  user.resetPassword = fn(self, oldPwd, newPwd) ::
    if oldPwd == self["password"] ::
      self["password"] = newPwd
      return "Password updated successfully"
    else ::
      return "Current password is incorrect"
    end
  end

  return user
end

const user = createUser("alice", "secret123")
println(user.login("wrong"))
println(user.login("secret123"))
println("Authenticated: ", user.isAuthenticated)
println(user.logout)

# ==========================================
# 4. BANK ACCOUNT
# ==========================================

print("\n--- Bank Account System ---")

fn createBankAccount(accountNumber, initialBalance) ::
  const account = {
    "accountNumber": accountNumber,
    "balance": initialBalance,
    "transactions": []
  }

  account.deposit = fn(self, amount) ::
    self["balance"] = self["balance"] + amount
    const tx = {"type": "deposit", "amount": amount}
    self["transactions"] = self["transactions"].push(tx)
    return "Deposited $" + amount.to_string + ". New balance: $" + self["balance"].to_string
  end

  account.withdraw = fn(self, amount) ::
    if amount > self["balance"] ::
      return "Insufficient funds. Balance: $" + self["balance"].to_string
    else ::
      self["balance"] = self["balance"] - amount
      const tx = {"type": "withdrawal", "amount": amount}
      self["transactions"] = self["transactions"].push(tx)
      return "Withdrew $" + amount.to_string + ". New balance: $" + self["balance"].to_string
    end
  end

  account.getBalance = fn(self) ::
    return self["balance"]
  end

  account.statement = fn(self) ::
    var result = "Account: " + self["accountNumber"].to_string + "\n"
    result = result + "Balance: $" + self["balance"].to_string + "\n"
    result = result + "Transactions: " + self["transactions"].len.to_string
    return result
  end

  return account
end

const myAccount = createBankAccount(12345, 1000)
println(myAccount.deposit(500))
println(myAccount.withdraw(200))
println(myAccount.withdraw(2000))
println("\n" + myAccount.statement)

# ==========================================
# 5. TIMER/STOPWATCH
# ==========================================

print("\n--- Timer/Stopwatch ---")

fn createStopwatch() ::
  const watch = {"startTime": 0, "elapsed": 0, "running": false}

  watch.start = fn(self) ::
    const running = self["running"]
    if running ::
      return "Stopwatch already running"
    else ::
      self["running"] = true
      return "Stopwatch started"
    end
  end

  watch.stop = fn(self) ::
    const running = self["running"]
    if running ::
      self["running"] = false
      self["elapsed"] = self["elapsed"] + 1  # Simplified: increment by 1
      return "Stopwatch stopped. Elapsed: " + self["elapsed"].to_string + " units"
    else ::
      return "Stopwatch not running"
    end
  end

  watch.reset = fn(self) ::
    self["elapsed"] = 0
    self["running"] = false
    return "Stopwatch reset"
  end

  watch.getElapsed = fn(self) ::
    return self["elapsed"]
  end

  return watch
end

var stopwatch = createStopwatch()
println(stopwatch.start)
println(stopwatch.stop)
println(stopwatch.start)
println(stopwatch.stop)
println("Total elapsed: ", stopwatch.getElapsed)
println(stopwatch.reset)

# ==========================================
# 6. VALIDATOR
# ==========================================

print("\n--- Form Validator ---")

fn createValidator() ::
  const validator = {"errors": []}

  validator.required = fn(self, value, fieldName) ::
    # Simple check for empty string
    if value == "" ::
      self["errors"] = self["errors"].push(fieldName + " is required")
    end
    return self
  end

  validator.minLength = fn(self, value, minLen, fieldName) ::
    if value.length < minLen ::
      const msg = fieldName + " must be at least " + minLen.to_string + " characters"
      self["errors"] = self["errors"].push(msg)
    end
    return self
  end

  validator.isValid = fn(self) ::
    return self["errors"].len == 0
  end

  validator.getErrors = fn(self) ::
    var result = "Validation errors:"
    for error in self["errors"] ::
      result = result + "\n  - " + error
    end
    return result
  end

  validator.reset = fn(self) ::
    self["errors"] = []
    return self
  end

  return validator
end

var validator = createValidator()
validator = validator.required("", "Username")
validator = validator.minLength("ab", 3, "Password")

const isValid = validator.isValid
println("Valid: ", isValid)
if isValid ::
  println("All fields valid!")
else ::
  println(validator.getErrors)
end

# ==========================================
# 7. CACHE SYSTEM
# ==========================================

print("\n--- Simple Cache System ---")

fn createCache(maxSize) ::
  const cache = {"data": {}, "maxSize": maxSize, "size": 0}

  cache.set = fn(self, key, value) ::
    if self["size"] < self["maxSize"] ::
      self["data"][key] = value
      self["size"] = self["size"] + 1
      return "Cached: " + key
    else ::
      return "Cache full! Max size: " + self["maxSize"].to_string
    end
  end

  cache.get = fn(self, key) ::
    return self["data"][key]
  end

  cache.has = fn(self, key) ::
    # Simple existence check
    return self["size"] > 0
  end

  cache.clear = fn(self) ::
    self["data"] = {}
    self["size"] = 0
    return "Cache cleared"
  end

  cache.stats = fn(self) ::
    return "Cache: " + self["size"].to_string + "/" + self["maxSize"].to_string + " items"
  end

  return cache
end

var cache = createCache(3)
println(cache.set("user1", "Alice"))
println(cache.set("user2", "Bob"))
println(cache.stats)
println("Get user1: ", cache.get("user1"))

# ==========================================
# 8. LOGGER SYSTEM
# ==========================================

print("\n--- Logger System ---")

fn createLogger(name) ::
  const logger = {"name": name, "logs": []}

  logger.info = fn(self, message) ::
    const log = "[INFO] " + self["name"] + ": " + message
    self["logs"] = self["logs"].push(log)
    return log
  end

  logger.error = fn(self, message) ::
    const log = "[ERROR] " + self["name"] + ": " + message
    self["logs"] = self["logs"].push(log)
    return log
  end

  logger.warn = fn(self, message) ::
    const log = "[WARN] " + self["name"] + ": " + message
    self["logs"] = self["logs"].push(log)
    return log
  end

  logger.getHistory = fn(self) ::
    var result = "Log history (" + self["logs"].len.to_string + " entries):"
    for log in self["logs"] ::
      result = result + "\n  " + log
    end
    return result
  end

  return logger
end

var logger = createLogger("MyApp")
println(logger.info("Application started"))
println(logger.warn("Low memory warning"))
println(logger.error("Database connection failed"))
println("\n" + logger.getHistory)

print("\n=== All Real-World Examples Complete! ===\n")





#|
Todo List Manager - Real-world application example
Demonstrates:
- Data structures (arrays, maps)
- CRUD operations
- User-defined methods
- String interpolation
- Constants
- Module pattern
- Function composition
|#

print("=== Todo List Manager ===\n")

#| Todo Module - Encapsulates all todo list functionality |#
module TodoList ::

  # Storage for todos
  var todos = []
  var nextId = 1

  # Create a new todo item
  fn create(title, description) ::
    var todo = {
      "id": nextId,
      "title": title,
      "description": description,
      "completed": false,
      "createdAt": nextId  # Using ID as timestamp for now
    }

    todos = todos.push(todo)
    nextId = nextId + 1

    return todo
  end

  # Get all todos
  fn getAll() ::
    return todos
  end

  # Get a todo by ID
  fn getById(id) ::
    for todo in todos ::
      if todo["id"] == id ::
        return todo
      end
    end
    return null
  end

  # Update a todo
  fn update(id, updates) ::
    for i in 0..todos.len() ::
      if todos[i]["id"] == id ::
        # Update title if provided
        if updates["title"] ::
          todos[i]["title"] = updates["title"]
        end

        # Update description if provided
        if updates["description"] ::
          todos[i]["description"] = updates["description"]
        end

        # Update completed status if provided
        if updates["completed"] ::
          todos[i]["completed"] = updates["completed"]
        end

        return todos[i]
      end
    end
    return null
  end

  # Delete a todo
  fn delete(id) ::
    var newTodos = []
    var found = false

    for todo in todos ::
      if todo["id"] == id ::
        found = true
      end
      if todo["id"] != id ::
        newTodos = newTodos.push(todo)
      end
    end

    todos = newTodos
    return found
  end

  # Mark todo as completed
  fn complete(id) ::
    return update(id, {"completed": true})
  end

  # Mark todo as incomplete
  fn uncomplete(id) ::
    return update(id, {"completed": false})
  end

  # Get only completed todos
  fn getCompleted() ::
    var completed = []
    for todo in todos ::
      if todo["completed"] ::
        completed = completed.push(todo)
      end
    end
    return completed
  end

  # Get only pending todos
  fn getPending() ::
    var pending = []
    for todo in todos ::
      if !todo["completed"] ::
        pending = pending.push(todo)
      end
    end
    return pending
  end

  # Get count of todos
  fn count() ::
    return todos.len()
  end

  # Get count of completed todos
  fn countCompleted() ::
    var count = 0
    for todo in todos ::
      if todo["completed"] ::
        count = count + 1
      end
    end
    return count
  end

  # Get count of pending todos
  fn countPending() ::
    return count() - countCompleted()
  end

  # Clear all todos
  fn clear() ::
    todos = []
    nextId = 1
  end

  # Display a single todo
  fn displayTodo(todo) ::
    var status = case todo["completed"] ::
      true => "[✓]"
      false => "[ ]"
      _ => "[?]"
    end

    print("#{status} ##{todo["id"]}: #{todo["title"]}")
    print("    #{todo["description"]}")
  end

  # Display all todos
  fn displayAll() ::
    if todos.len() == 0 ::
      print("No todos yet!")
      return null
    end

    print("\n--- All Todos (#{count()}) ---")
    for todo in todos ::
      displayTodo(todo)
    end
  end

  # Display summary
  fn displaySummary() ::
    print("\n=== Summary ===")
    print("Total: #{count()}")
    print("Completed: #{countCompleted()}")
    print("Pending: #{countPending()}")
  end

end

#| Demo: Using the Todo List Manager |#

print("\n1. Creating todos...")
var todo1 = TodoList.create("Buy groceries", "Milk, eggs, bread, coffee")
var todo2 = TodoList.create("Finish project", "Complete the programming language implementation")
var todo3 = TodoList.create("Exercise", "Go for a 30-minute run")
var todo4 = TodoList.create("Read book", "Read chapter 5 of 'The Pragmatic Programmer'")

print("Created #{TodoList.count()} todos\n")

print("2. Displaying all todos:")
TodoList.displayAll()

print("\n3. Completing some todos...")
TodoList.complete(1)
TodoList.complete(3)
print("Completed todos #1 and #3")

TodoList.displayAll()
TodoList.displaySummary()

print("\n4. Updating a todo...")
TodoList.update(2, {
  "title": "Finish language implementation",
  "description": "Complete the programming language with all features and examples"
})
print("Updated todo #2")

TodoList.displayAll()

print("\n5. Getting specific todo...")
var specificTodo = TodoList.getById(2)
if specificTodo ::
  print("Found todo #2:")
  TodoList.displayTodo(specificTodo)
end

print("\n6. Filtering todos...")
print("\nCompleted todos:")
var completedTodos = TodoList.getCompleted()
for todo in completedTodos ::
  TodoList.displayTodo(todo)
end

print("\nPending todos:")
var pendingTodos = TodoList.getPending()
for todo in pendingTodos ::
  TodoList.displayTodo(todo)
end

print("\n7. Deleting a todo...")
var deleted = TodoList.delete(3)
if deleted ::
  print("Deleted todo #3")
end

TodoList.displayAll()
TodoList.displaySummary()

print("\n8. Adding more todos...")
TodoList.create("Learn new language feature", "Study string interpolation syntax")
TodoList.create("Write documentation", "Document all language features")

TodoList.displayAll()
TodoList.displaySummary()

#| Test with user-defined array methods if available |#
print("\n9. Advanced filtering with custom methods...")

# Define a filter method for arrays if not already defined
Array.filter = fn(arr, predicate) ::
  var result = []
  for item in arr ::
    if predicate(item) ::
      result = result.push(item)
    end
  end
  return result
end

# Define a map method for arrays if not already defined
Array.map = fn(arr, transform) ::
  var result = []
  for item in arr ::
    result = result.push(transform(item))
  end
  return result
end

# Get all todos and extract just titles
var allTodos = TodoList.getAll()
var titles = allTodos.map(fn(todo) :: return todo["title"] end)

print("\nAll todo titles:")
for i in 0...titles.len() ::
  print("  #{i + 1}. #{titles[i]}")
end

# Filter todos with long descriptions (> 30 chars)
var longTodos = allTodos.filter(fn(todo) ::
  return todo["description"].length() > 30
end)

print("\nTodos with long descriptions:")
for todo in longTodos ::
  TodoList.displayTodo(todo)
end

print("\n=== Todo List Manager Demo Complete ===")

#|
Observations and Missing Features Discovered:
1. Need a way to check if map key exists (currently using truthy check)
2. Need null coalescing or default value syntax
3. Could use spread operator for map merging
4. Need better way to handle optional parameters
5. String.length() works but could also support len() for consistency
6. No built-in way to get map keys/values as arrays
7. No JSON serialization for saving/loading todos
8. No file I/O for persistence
9. No way to get current timestamp/date
10. Logical NOT (!) works but could document better
11. Could use Array.forEach() method
12. Could use Array.find() method
13. Need try/catch for error handling
14. Type checking functions (isString, isNumber, isMap, etc.) would be helpful
|#





